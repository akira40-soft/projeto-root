console.log("üü¢ Iniciando o script corrected_bot.js com Baileys...");

const {
    default: makeWASocket,
    useMultiFileAuthState,
    DisconnectReason,
    fetchLatestBaileysVersion,
    isJidGroup,
    jidNormalizedUser
} = require("@whiskeysockets/baileys");
const pino = require("pino");
const { Boom } = require("@hapi/boom");
const axios = require("axios");
const fs = require("fs");
const path = require("path");
const qrcodeTerminal = require("qrcode-terminal");

// --- Configura√ß√µes Essenciais ---
const BOT_NAME_TRIGGER = "akira"; // Palavra-chave para ativar o bot em grupos (case-insensitive)
const RENDER_API_URL = process.env.RENDER_API_URL || "https://sua-api-python.onrender.com/webhook"; // !! SUBSTITUA PELA URL DA SUA API NO RENDER ou use vari√°vel de ambiente !!
const AUTH_DIR = "baileys_auth_info_corrected"; // Diret√≥rio para guardar informa√ß√µes de autentica√ß√£o
const REQUEST_TIMEOUT = 120000; // Timeout para a API do Render (2 minutos)
const MAX_RETRIES = 2; // Tentativas de envio para a API
const RETRY_DELAY = 5000; // Delay entre tentativas (5 segundos)
// -------------------------------

const logger = pino({ level: process.env.LOG_LEVEL || "info" }); // Use 'debug' para mais detalhes

let sock = null;
let botJid = null;
let botLid = null; // Para armazenar o LID do bot, se dispon√≠vel

async function connectToWhatsApp() {
    logger.info("Iniciando conex√£o com o WhatsApp...");
    const { state, saveCreds } = await useMultiFileAuthState(AUTH_DIR);
    const { version, isLatest } = await fetchLatestBaileysVersion();
    logger.info(`Usando Baileys v${version.join(".")}, √© a mais recente: ${isLatest}`);

    sock = makeWASocket({
        version,
        logger,
        printQRInTerminal: false, // Geraremos manualmente para melhor visualiza√ß√£o
        auth: state,
        browser: ["Akira (Manus)", "Chrome", "1.0.0"], // Define um nome de browser personalizado
        syncFullHistory: false, // Sincroniza apenas o necess√°rio
        markOnlineOnConnect: true, // Marca como online ao conectar
        // getMessage: async key => { 
        //     // Implementar busca de mensagens se necess√°rio para contexto complexo
        //     // Exemplo: return store.loadMessage(key.remoteJid, key.id)
        //     return undefined; 
        // }
    });

    // --- Tratamento de Eventos da Conex√£o ---
    sock.ev.on("connection.update", async (update) => {
        const { connection, lastDisconnect, qr } = update;
        logger.info(`Atualiza√ß√£o da conex√£o: ${connection}`);

        if (qr) {
            logger.info("QR Code recebido. Escaneie abaixo ou use o c√≥digo:");
            qrcodeTerminal.generate(qr, { small: true });
            logger.info(`C√≥digo QR (para inserir manualmente): ${qr}`);
            // Opcional: Salvar QR em ficheiro
            // const qrPath = path.join(__dirname, 'qr_code.png');
            // await require('qrcode').toFile(qrPath, qr).catch(e => logger.error('Erro ao salvar QR:', e));
        }

        if (connection === "close") {
            const statusCode = (lastDisconnect?.error instanceof Boom) ? lastDisconnect.error.output.statusCode : 500;
            const shouldReconnect = statusCode !== DisconnectReason.loggedOut;
            logger.error(`Conex√£o fechada! Raz√£o: ${statusCode} - ${lastDisconnect?.error?.message}. Reconectando: ${shouldReconnect}`);
            
            // Limpar JID do bot ao desconectar
            botJid = null;
            botLid = null;

            if (shouldReconnect) {
                setTimeout(connectToWhatsApp, 5000); // Tenta reconectar ap√≥s 5s
            } else {
                logger.error("Desconectado permanentemente (logout). Remova a pasta de autentica√ß√£o e reinicie.");
                // Opcional: Remover pasta de autentica√ß√£o automaticamente
                // fs.rmSync(AUTH_DIR, { recursive: true, force: true });
                process.exit(1); // Encerra se for logout
            }
        } else if (connection === "open") {
            logger.info("Conex√£o com WhatsApp estabelecida!");
            // Armazena o JID e LID do bot
            botJid = jidNormalizedUser(sock.user.id);
            botLid = sock.user.lid; // Pode ser undefined
            logger.info(`Bot JID: ${botJid}`);
            if (botLid) logger.info(`Bot LID: ${botLid}`);
            // Opcional: Limpar QR code se existir
            // if (fs.existsSync(path.join(__dirname, 'qr_code.png'))) fs.unlinkSync(path.join(__dirname, 'qr_code.png'));
        }
    });

    // Salvar credenciais
    sock.ev.on("creds.update", saveCreds);

    // --- Tratamento de Novas Mensagens ---
    sock.ev.on("messages.upsert", async (m) => {
        // logger.debug({ m }, "Evento messages.upsert recebido"); // Log detalhado do evento
        const msg = m.messages[0];

        // Ignorar notifica√ß√µes e mensagens sem conte√∫do real
        if (!msg.message || msg.key.remoteJid === 'status@broadcast') {
            // logger.debug("Mensagem ignorada (notifica√ß√£o ou status)");
            return;
        }

        // Ignorar mensagens enviadas pelo pr√≥prio bot
        if (msg.key.fromMe) {
            // logger.debug("Mensagem ignorada (enviada pelo bot)");
            return;
        }

        try {
            await processMessage(msg);
        } catch (error) {
            logger.error({ err: error, msgKey: msg.key }, "Erro ao processar mensagem");
        }
    });

    return sock;
}

// --- Fun√ß√£o Principal de Processamento de Mensagem ---
async function processMessage(msg) {
    const chatId = msg.key.remoteJid;
    const isGroup = isJidGroup(chatId);
    const messageTimestamp = typeof msg.messageTimestamp === 'number' ? msg.messageTimestamp : (msg.messageTimestamp?.low || Date.now() / 1000);

    // --- Extra√ß√£o de Informa√ß√µes do Remetente ---
    let senderJid = msg.key.participant || msg.key.remoteJid; // Em grupo usa participant, sen√£o remoteJid
    senderJid = jidNormalizedUser(senderJid); // Garante formato numero@s.whatsapp.net
    const senderName = msg.pushName || senderJid.split('@')[0]; // Usa pushName ou o n√∫mero como fallback
    const senderNumber = senderJid.split('@')[0]; // Apenas o n√∫mero

    // --- Extra√ß√£o do Texto da Mensagem ---
    let messageText = '';
    const messageType = Object.keys(msg.message)[0];

    if (messageType === 'conversation') {
        messageText = msg.message.conversation;
    } else if (messageType === 'extendedTextMessage') {
        messageText = msg.message.extendedTextMessage.text;
    } else if (msg.message.imageMessage?.caption) {
        messageText = msg.message.imageMessage.caption;
    } else if (msg.message.videoMessage?.caption) {
        messageText = msg.message.videoMessage.caption;
    } else if (msg.message.documentMessage?.caption) {
        messageText = msg.message.documentMessage.caption;
    }
    messageText = messageText?.trim() || ''; // Garante que √© string e remove espa√ßos extras

    // Ignorar mensagens sem texto (ex: apenas m√≠dia, rea√ß√µes, chamadas, etc.)
    // Permitimos m√≠dia COM caption (texto)
    if (!messageText && messageType !== 'extendedTextMessage') { // extendedTextMessage pode ter contexto sem texto principal
         // logger.debug({ msgKey: msg.key, type: messageType }, "Mensagem ignorada (sem texto relevante)");
         // return; // Comentado para permitir an√°lise de contexto mesmo sem texto
    }
    
    // Ignorar rea√ß√µes explicitamente
    if (messageType === 'reactionMessage') {
        logger.info(`Rea√ß√£o de ${senderName} (${senderNumber}) ignorada.`);
        return;
    }

    logger.info(`Mensagem recebida de ${senderName} (${senderNumber}) em ${isGroup ? 'grupo' : 'privado'} (${chatId}): "${messageText.slice(0, 50)}..." (Tipo: ${messageType})`);

    // --- L√≥gica de Ativa√ß√£o (Principalmente para Grupos) ---
    let shouldProcess = false;
    let activationReason = '';
    let groupMetadata = null;
    let groupName = null;
    let repliedMessageText = null;
    let repliedMessageSenderJid = null;

    const contextInfo = msg.message.extendedTextMessage?.contextInfo;

    // 1. Verificar se √© Reply
    const isReply = !!contextInfo?.quotedMessage;
    let isReplyToBot = false;
    if (isReply && botJid) {
        const quotedParticipant = contextInfo.participant ? jidNormalizedUser(contextInfo.participant) : null;
        // Verifica se o autor da mensagem citada √© o bot (comparando JIDs)
        isReplyToBot = quotedParticipant === botJid || (botLid && quotedParticipant === botLid);
        
        if (isReplyToBot) {
            // Extrair texto da mensagem respondida
            const quotedMsg = contextInfo.quotedMessage;
            if (quotedMsg?.conversation) {
                repliedMessageText = quotedMsg.conversation;
            } else if (quotedMsg?.extendedTextMessage?.text) {
                repliedMessageText = quotedMsg.extendedTextMessage.text;
            } // Adicionar mais tipos se necess√°rio (caption de m√≠dia, etc.)
            repliedMessageText = repliedMessageText?.trim() || null;
            repliedMessageSenderJid = quotedParticipant; // JID de quem enviou a msg original (o bot)
        }
    }

    // 2. Verificar se foi chamado pelo nome (case-insensitive)
    const isCalledByName = messageText.toLowerCase().includes(BOT_NAME_TRIGGER);

    // 3. Verificar se foi mencionado (@)
    let isMentioned = false;
    if (contextInfo?.mentionedJid && botJid) {
        isMentioned = contextInfo.mentionedJid.some(jid => {
            const normalizedMention = jidNormalizedUser(jid);
            return normalizedMention === botJid || (botLid && normalizedMention === botLid);
        });
    }

    // --- Decis√£o de Processamento ---
    if (!isGroup) {
        shouldProcess = true; // Processar sempre em chats privados
        activationReason = 'Mensagem Privada';
    } else {
        // Em grupos, processar se for chamado, mencionado ou reply ao bot
        if (isCalledByName) {
            shouldProcess = true;
            activationReason = `Chamado pelo nome ('${BOT_NAME_TRIGGER}')`;
        } else if (isMentioned) {
            shouldProcess = true;
            activationReason = 'Mencionado (@)';
        } else if (isReplyToBot) {
            shouldProcess = true;
            activationReason = 'Resposta a mensagem do Bot';
        }
        
        // Obter nome do grupo se for processar
        if (shouldProcess) {
             try {
                groupMetadata = await sock.groupMetadata(chatId);
                groupName = groupMetadata?.subject || chatId; // Usa nome do grupo ou ID se nome n√£o dispon√≠vel
            } catch (err) {
                logger.warn({ err, chatId }, "Erro ao obter metadados do grupo");
                groupName = chatId; // Fallback para ID do grupo
            }
        }
    }

    // --- Envio para a API (se deve processar) ---
    if (shouldProcess) {
        logger.info(`Ativa√ß√£o: ${activationReason}. Preparando para enviar para a API...`);

        // Construir Payload
        const payload = {
            sender: {
                jid: senderJid,
                number: senderNumber,
                name: senderName
            },
            chat: {
                id: chatId,
                isGroup: isGroup,
                groupName: groupName // Ser√° null se n√£o for grupo ou erro ao obter
            },
            message: {
                id: msg.key.id,
                text: messageText || null, // Envia null se n√£o houver texto (ex: reply sem texto novo)
                type: messageType,
                timestamp: messageTimestamp
            },
            replyContext: isReplyToBot ? {
                originalMessageText: repliedMessageText,
                originalSenderJid: repliedMessageSenderJid // JID do bot
            } : null
        };

        logger.debug({ payload }, "Payload a ser enviado para a API");

        // Enviar para a API com retentativas
        try {
            const response = await makeRequestWithRetry(RENDER_API_URL, payload, REQUEST_TIMEOUT);
            logger.info(`Resposta da API recebida (Status: ${response.status})`);
            // logger.debug({ responseData: response.data }, "Dados da resposta da API");

            // --- L√≥gica Opcional para Responder ao Usu√°rio via Bot ---
            if (response.data && response.data.reply) {
                const replyText = response.data.reply;
                logger.info(`API solicitou resposta: "${replyText.slice(0, 50)}..."`);
                await sock.presenceSubscribe(chatId) // Garante que a presen√ßa est√° subscrita
                await sock.sendPresenceUpdate('composing', chatId) // Simula digita√ß√£o
                await new Promise(resolve => setTimeout(resolve, 500 + Math.random() * 1000)); // Delay digita√ß√£o
                await sock.sendMessage(chatId, { text: replyText });
                await sock.sendPresenceUpdate('paused', chatId) // Para digita√ß√£o
                logger.info(`Resposta enviada para ${chatId}`);
            } else {
                logger.info("API n√£o solicitou resposta.");
            }

        } catch (error) {
            logger.error({ err: error, apiUrl: RENDER_API_URL }, "Falha ao enviar dados para a API ap√≥s retentativas");
            // Opcional: Enviar mensagem de erro ao usu√°rio?
            // try {
            //     await sock.sendMessage(chatId, { text: "Desculpe, ocorreu um erro interno ao processar sua solicita√ß√£o. Tente novamente mais tarde." });
            // } catch (sendError) {
            //     logger.error({ sendError }, "Erro ao enviar mensagem de falha ao usu√°rio");
            // }
        }

    } else if (isGroup) {
        logger.info(`Mensagem no grupo ${chatId} ignorada (n√£o ativou o bot).`);
    }
}

// --- Fun√ß√£o Auxiliar para Requisi√ß√µes com Retentativa ---
async function makeRequestWithRetry(url, data, timeout, method = 'POST') {
    for (let attempt = 1; attempt <= MAX_RETRIES + 1; attempt++) {
        try {
            logger.info(`Enviando requisi√ß√£o ${method} para ${url} (Tentativa ${attempt}/${MAX_RETRIES + 1}) - Timeout: ${timeout / 1000}s`);
            const startTime = Date.now();
            const response = await axios({
                method,
                url,
                data: method === 'POST' ? data : undefined,
                timeout,
                headers: {
                    'Content-Type': 'application/json',
                    'User-Agent': 'Akira-Baileys-Bot/1.0'
                }
            });
            const duration = Date.now() - startTime;
            logger.info(`‚úÖ Resposta da API (${response.status}) recebida em ${duration}ms.`);
            return response;
        } catch (error) {
            const errorType = error.code === 'ECONNABORTED' ? 'TIMEOUT' :
                error.response?.status ? `HTTP_${error.response.status}` : 'NETWORK_ERROR';
            logger.warn(`Falha na tentativa ${attempt}: ${errorType} - ${error.message}`);
            if (attempt <= MAX_RETRIES) {
                logger.info(`Aguardando ${RETRY_DELAY / 1000}s antes de tentar novamente...`);
                await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
            } else {
                logger.error("Todas as tentativas de requisi√ß√£o falharam.");
                throw error; // Lan√ßa o erro ap√≥s a √∫ltima tentativa
            }
        }
    }
}

// --- Inicializa√ß√£o ---
connectToWhatsApp().catch(err => {
    logger.fatal({ err }, "Erro fatal ao iniciar a conex√£o com o WhatsApp");
    process.exit(1);
});

// --- Tratamento de Encerramento Graceful ---
process.on('SIGINT', async () => {
    logger.info("Recebido SIGINT. Desconectando...");
    if (sock) {
        await sock.logout(); // Tenta deslogar corretamente
        logger.info("Logout realizado.");
    }
    process.exit(0);
});

process.on('SIGTERM', async () => {
    logger.info("Recebido SIGTERM. Desconectando...");
    if (sock) {
        await sock.logout();
        logger.info("Logout realizado.");
    }
    process.exit(0);
});

logger.info("Script corrected_bot.js carregado. Aguardando conex√£o...");

